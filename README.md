# lp1
## Цель: Простой REST API для блога
### Участники:
Тормышев Игорь Валерьевич  
Резников Дмитрий Игоревич  


# Задача 1-1: Настройка Flask, модели Post/Comment, SQLite

## Описание
Настройка базовой инфраструктуры Flask приложения с моделями данных для блога.

## Что реализовано

### 1. Настройка Flask приложения
- Создан основной файл `app.py` с конфигурацией Flask
- Настроена SQLite база данных
- Добавлена поддержка Flask-Migrate для миграций

### 2. Модели данных

#### Модель Post
- `id` - уникальный идентификатор
- `title` - заголовок поста (максимум 200 символов)
- `content` - содержимое поста
- `created_at` - дата создания
- `updated_at` - дата последнего обновления
- `comments` - связь с комментариями (один-ко-многим)

#### Модель Comment
- `id` - уникальный идентификатор
- `post_id` - ссылка на пост
- `content` - содержимое комментария
- `author` - автор комментария
- `created_at` - дата создания

### 3. Функциональность
- Автоматическое создание таблиц при запуске
- Методы `to_dict()` для сериализации в JSON
- Базовый маршрут `/` для проверки работы API

## Установка и запуск

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python run.py
```

3. Проверьте работу:
```bash
curl http://localhost:5050/
```

## Структура файлов
```
1-1/
├── app.py              # Основное приложение Flask
├── run.py              # Точка входа
├── requirements.txt    # Зависимости Python
└── README.md          # Документация
```

## Следующие шаги
- Реализация CRUD операций для постов (задача 1-2)
- Добавление API эндпоинтов для комментариев (задача 2-1)

# Задача 1-2: Модели данных

## Описание
Создание моделей данных для блога с настройкой связей между сущностями.

## Реализованные модели

### 1. Модель Post
```python
class Post(db.Model):
    __tablename__ = 'posts'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Связь с комментариями (один-ко-многим)
    comments = db.relationship('Comment', backref='post', lazy=True, cascade='all, delete-orphan')
```

**Поля:**
- `id` - уникальный идентификатор (автоинкремент)
- `title` - заголовок поста (максимум 200 символов)
- `content` - содержимое поста (текст)
- `created_at` - дата создания (автоматически)
- `updated_at` - дата обновления (автоматически)

### 2. Модель Comment
```python
class Comment(db.Model):
    __tablename__ = 'comments'
    
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('posts.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    author = db.Column(db.String(100), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
```

**Поля:**
- `id` - уникальный идентификатор (автоинкремент)
- `post_id` - ссылка на пост (внешний ключ)
- `content` - содержимое комментария
- `author` - автор комментария (максимум 100 символов)
- `created_at` - дата создания (автоматически)

## Связи между моделями

### Один-ко-многим (Post → Comment)
- Один пост может иметь много комментариев
- Один комментарий принадлежит одному посту
- При удалении поста все комментарии удаляются автоматически (cascade)

### Настройка связей
```python
# В модели Post
comments = db.relationship('Comment', backref='post', lazy=True, cascade='all, delete-orphan')

# В модели Comment
post_id = db.Column(db.Integer, db.ForeignKey('posts.id'), nullable=False)
```

## Методы моделей

### to_dict()
Каждая модель имеет метод `to_dict()` для сериализации в JSON:
```python
def to_dict(self):
    return {
        'id': self.id,
        'title': self.title,
        'content': self.content,
        'created_at': self.created_at.isoformat(),
        'updated_at': self.updated_at.isoformat()
    }
```

## Миграции базы данных

### Автоматическое создание таблиц
```python
@app.before_first_request
def create_tables():
    db.create_all()
```

### Flask-Migrate
Настроен Flask-Migrate для управления миграциями:
```python
migrate = Migrate(app, db)
```

## Установка и запуск

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python run.py
```

3. Проверьте работу:
```bash
curl http://localhost:5050/
```

## Структура файлов
```
1-2/
├── app.py              # Flask приложение с моделями
├── run.py              # Точка входа
├── requirements.txt    # Зависимости Python
└── README.md          # Документация
```

## Следующие шаги
- Реализация CRUD операций для постов (задача 1-3)
- Добавление обработки ошибок (задача 1-4)  

# Задача 1-3: Обработка ошибок и логирование

## Описание
Улучшение API с добавлением комплексной обработки ошибок, валидации данных и логирования.

## Новые возможности

### 1. Логирование
- **Файл логов**: `blog_api.log`
- **Консольный вывод**: Дублирование логов в консоль
- **Уровни логирования**: INFO, WARNING, ERROR
- **Структурированные логи**: Время, уровень, сообщение

### 2. Обработка ошибок
- **HTTP 400**: Неверный запрос, ошибки валидации
- **HTTP 404**: Ресурс не найден
- **HTTP 405**: Метод не разрешен
- **HTTP 500**: Внутренняя ошибка сервера

### 3. Валидация данных
- **Заголовок поста**: 3-200 символов
- **Содержимое поста**: минимум 10 символов
- **Обязательные поля**: title и content
- **Очистка данных**: удаление лишних пробелов

### 4. Декоратор логирования
- Автоматическое логирование всех запросов
- Отслеживание успешных и неудачных операций
- Логирование IP-адресов клиентов

## Примеры ответов об ошибках

### Ошибка валидации (400)
```json
{
  "success": false,
  "error": "Ошибки валидации",
  "message": "Заголовок должен содержать минимум 3 символа; Содержимое должно содержать минимум 10 символов"
}
```

### Ресурс не найден (404)
```json
{
  "success": false,
  "error": "Пост не найден",
  "message": "Пост с ID 999 не существует"
}
```

### Внутренняя ошибка (500)
```json
{
  "success": false,
  "error": "Ошибка при создании поста",
  "message": "Не удалось создать пост"
}
```

## Установка и запуск

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python run.py
```

3. Тестирование обработки ошибок:
```bash
python test_errors.py
```

## Тестирование

Скрипт `test_errors.py` проверяет:
- Несуществующие эндпоинты
- Несуществующие ресурсы
- Невалидные данные
- Неверные HTTP методы
- Граничные случаи валидации

## Логирование

### Примеры логов:
```
2024-01-01 12:00:00,123 - __main__ - INFO - Запрос: POST /posts от 127.0.0.1
2024-01-01 12:00:00,456 - __main__ - INFO - Создан новый пост с ID 1: Мой первый пост
2024-01-01 12:00:00,789 - __main__ - INFO - Ответ: POST /posts - Успешно
```

### Ошибки:
```
2024-01-01 12:00:00,123 - __main__ - WARNING - Ошибки валидации при создании поста: ['Заголовок должен содержать минимум 3 символа']
2024-01-01 12:00:00,456 - __main__ - ERROR - Ошибка при создании поста: database connection failed
```

## Структура файлов
```
1-3/
├── app.py              # Flask приложение с обработкой ошибок
├── run.py              # Точка входа
├── test_errors.py      # Тестирование обработки ошибок
├── blog_api.log        # Файл логов (создается автоматически)
├── requirements.txt    # Зависимости Python
└── README.md          # Документация
```

## Улучшения по сравнению с предыдущими версиями

1. **Детальная валидация**: Проверка длины полей, обязательных данных
2. **Структурированные ошибки**: Единый формат ответов об ошибках
3. **Комплексное логирование**: Отслеживание всех операций
4. **Обработка исключений**: Graceful handling всех ошибок
5. **Безопасность**: Валидация и очистка входных данных

## Следующие шаги
- Реализация API эндпоинтов для комментариев (задача 2-1)
- Добавление валидации для комментариев (задача 2-2)

# Задача 2-1: API эндпоинты для комментариев

## Описание
Реализация полного набора CRUD операций для комментариев в REST API с интеграцией с постами.

## Реализованные эндпоинты для комментариев

### 1. GET /posts/{id}/comments
**Описание**: Получить все комментарии к посту
**Метод**: GET
**Параметры**: `id` - ID поста
**Ответ**:
```json
{
  "success": true,
  "data": [
    {
      "id": 1,
      "post_id": 1,
      "content": "Отличный пост!",
      "author": "Алексей",
      "created_at": "2024-01-01T12:00:00"
    }
  ],
  "count": 1,
  "post_id": 1
}
```

### 2. POST /posts/{id}/comments
**Описание**: Создать новый комментарий к посту
**Метод**: POST
**Параметры**: `id` - ID поста
**Тело запроса**:
```json
{
  "content": "Отличный пост!",
  "author": "Алексей"
}
```
**Ответ**:
```json
{
  "success": true,
  "data": {
    "id": 1,
    "post_id": 1,
    "content": "Отличный пост!",
    "author": "Алексей",
    "created_at": "2024-01-01T12:00:00"
  },
  "message": "Комментарий успешно создан"
}
```

### 3. GET /comments/{id}
**Описание**: Получить комментарий по ID
**Метод**: GET
**Параметры**: `id` - ID комментария
**Ответ**:
```json
{
  "success": true,
  "data": {
    "id": 1,
    "post_id": 1,
    "content": "Отличный пост!",
    "author": "Алексей",
    "created_at": "2024-01-01T12:00:00"
  }
}
```

### 4. PUT /comments/{id}
**Описание**: Обновить комментарий
**Метод**: PUT
**Параметры**: `id` - ID комментария
**Тело запроса**:
```json
{
  "content": "Обновленный комментарий",
  "author": "Алексей Петров"
}
```
**Ответ**:
```json
{
  "success": true,
  "data": {
    "id": 1,
    "post_id": 1,
    "content": "Обновленный комментарий",
    "author": "Алексей Петров",
    "created_at": "2024-01-01T12:00:00"
  },
  "message": "Комментарий успешно обновлен"
}
```

### 5. DELETE /comments/{id}
**Описание**: Удалить комментарий
**Метод**: DELETE
**Параметры**: `id` - ID комментария
**Ответ**:
```json
{
  "success": true,
  "message": "Комментарий успешно удален"
}
```

## Валидация данных для комментариев

### Правила валидации:
- **content**: 5-1000 символов (обязательное поле)
- **author**: 2-100 символов (обязательное поле)
- **post_id**: должен существовать в базе данных

### Пример ошибки валидации:
```json
{
  "success": false,
  "error": "Ошибки валидации",
  "message": "Содержимое комментария должно содержать минимум 5 символов; Имя автора должно содержать минимум 2 символа"
}
```

## Особенности реализации

### 1. Связь с постами
- Комментарии автоматически привязываются к постам
- При удалении поста все комментарии удаляются автоматически (cascade)
- Проверка существования поста при создании комментария

### 2. Сортировка комментариев
- Комментарии сортируются по дате создания (новые сначала)
- Использование `order_by(Comment.created_at.desc())`

### 3. Логирование
- Детальное логирование всех операций с комментариями
- Отслеживание создания, обновления и удаления
- Логирование ошибок валидации

## Установка и запуск

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python run.py
```

3. Тестирование API комментариев:
```bash
python test_comments.py
```

## Тестирование

Скрипт `test_comments.py` проверяет:
- Создание комментариев к посту
- Получение всех комментариев к посту
- Получение конкретного комментария
- Обновление комментария
- Удаление комментария
- Валидацию данных
- Обработку ошибок (несуществующие посты/комментарии)
- Каскадное удаление при удалении поста

## Полный список эндпоинтов

### Посты:
- `GET /posts` - получить все посты
- `GET /posts/{id}` - получить пост по ID
- `POST /posts` - создать новый пост
- `PUT /posts/{id}` - обновить пост
- `DELETE /posts/{id}` - удалить пост

### Комментарии:
- `GET /posts/{id}/comments` - получить комментарии к посту
- `POST /posts/{id}/comments` - создать комментарий к посту
- `GET /comments/{id}` - получить комментарий по ID
- `PUT /comments/{id}` - обновить комментарий
- `DELETE /comments/{id}` - удалить комментарий

## Структура файлов
```
2-1/
├── app.py              # Flask приложение с API комментариев
├── run.py              # Точка входа
├── test_comments.py    # Тестирование API комментариев
├── requirements.txt    # Зависимости Python
└── README.md          # Документация
```

## Следующие шаги
- Улучшение валидации данных (задача 2-2)
- Написание тестов и документация (задача 2-3)
