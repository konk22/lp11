# lp1
## Цель: Простой REST API для блога
### Участники:
Тормышев Игорь Валерьевич  
Резников Дмитрий Игоревич  


# Задача 1-1: Настройка Flask, модели Post/Comment, SQLite

## Описание
Настройка базовой инфраструктуры Flask приложения с моделями данных для блога.

## Что реализовано

### 1. Настройка Flask приложения
- Создан основной файл `app.py` с конфигурацией Flask
- Настроена SQLite база данных
- Добавлена поддержка Flask-Migrate для миграций

### 2. Модели данных

#### Модель Post
- `id` - уникальный идентификатор
- `title` - заголовок поста (максимум 200 символов)
- `content` - содержимое поста
- `created_at` - дата создания
- `updated_at` - дата последнего обновления
- `comments` - связь с комментариями (один-ко-многим)

#### Модель Comment
- `id` - уникальный идентификатор
- `post_id` - ссылка на пост
- `content` - содержимое комментария
- `author` - автор комментария
- `created_at` - дата создания

### 3. Функциональность
- Автоматическое создание таблиц при запуске
- Методы `to_dict()` для сериализации в JSON
- Базовый маршрут `/` для проверки работы API

## Установка и запуск

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python run.py
```

3. Проверьте работу:
```bash
curl http://localhost:5050/
```

## Структура файлов
```
1-1/
├── app.py              # Основное приложение Flask
├── run.py              # Точка входа
├── requirements.txt    # Зависимости Python
└── README.md          # Документация
```

## Следующие шаги
- Реализация CRUD операций для постов (задача 1-2)
- Добавление API эндпоинтов для комментариев (задача 2-1)

# Задача 1-2: Модели данных

## Описание
Создание моделей данных для блога с настройкой связей между сущностями.

## Реализованные модели

### 1. Модель Post
```python
class Post(db.Model):
    __tablename__ = 'posts'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Связь с комментариями (один-ко-многим)
    comments = db.relationship('Comment', backref='post', lazy=True, cascade='all, delete-orphan')
```

**Поля:**
- `id` - уникальный идентификатор (автоинкремент)
- `title` - заголовок поста (максимум 200 символов)
- `content` - содержимое поста (текст)
- `created_at` - дата создания (автоматически)
- `updated_at` - дата обновления (автоматически)

### 2. Модель Comment
```python
class Comment(db.Model):
    __tablename__ = 'comments'
    
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('posts.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    author = db.Column(db.String(100), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
```

**Поля:**
- `id` - уникальный идентификатор (автоинкремент)
- `post_id` - ссылка на пост (внешний ключ)
- `content` - содержимое комментария
- `author` - автор комментария (максимум 100 символов)
- `created_at` - дата создания (автоматически)

## Связи между моделями

### Один-ко-многим (Post → Comment)
- Один пост может иметь много комментариев
- Один комментарий принадлежит одному посту
- При удалении поста все комментарии удаляются автоматически (cascade)

### Настройка связей
```python
# В модели Post
comments = db.relationship('Comment', backref='post', lazy=True, cascade='all, delete-orphan')

# В модели Comment
post_id = db.Column(db.Integer, db.ForeignKey('posts.id'), nullable=False)
```

## Методы моделей

### to_dict()
Каждая модель имеет метод `to_dict()` для сериализации в JSON:
```python
def to_dict(self):
    return {
        'id': self.id,
        'title': self.title,
        'content': self.content,
        'created_at': self.created_at.isoformat(),
        'updated_at': self.updated_at.isoformat()
    }
```

## Миграции базы данных

### Автоматическое создание таблиц
```python
@app.before_first_request
def create_tables():
    db.create_all()
```

### Flask-Migrate
Настроен Flask-Migrate для управления миграциями:
```python
migrate = Migrate(app, db)
```

## Установка и запуск

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python run.py
```

3. Проверьте работу:
```bash
curl http://localhost:5050/
```

## Структура файлов
```
1-2/
├── app.py              # Flask приложение с моделями
├── run.py              # Точка входа
├── requirements.txt    # Зависимости Python
└── README.md          # Документация
```

## Следующие шаги
- Реализация CRUD операций для постов (задача 1-3)
- Добавление обработки ошибок (задача 1-4)

# Задача 1-3: Обработка ошибок и логирование

## Описание
Улучшение API с добавлением комплексной обработки ошибок, валидации данных и логирования.

## Новые возможности

### 1. Логирование
- **Файл логов**: `blog_api.log`
- **Консольный вывод**: Дублирование логов в консоль
- **Уровни логирования**: INFO, WARNING, ERROR
- **Структурированные логи**: Время, уровень, сообщение

### 2. Обработка ошибок
- **HTTP 400**: Неверный запрос, ошибки валидации
- **HTTP 404**: Ресурс не найден
- **HTTP 405**: Метод не разрешен
- **HTTP 500**: Внутренняя ошибка сервера

### 3. Валидация данных
- **Заголовок поста**: 3-200 символов
- **Содержимое поста**: минимум 10 символов
- **Обязательные поля**: title и content
- **Очистка данных**: удаление лишних пробелов

### 4. Декоратор логирования
- Автоматическое логирование всех запросов
- Отслеживание успешных и неудачных операций
- Логирование IP-адресов клиентов

## Примеры ответов об ошибках

### Ошибка валидации (400)
```json
{
  "success": false,
  "error": "Ошибки валидации",
  "message": "Заголовок должен содержать минимум 3 символа; Содержимое должно содержать минимум 10 символов"
}
```

### Ресурс не найден (404)
```json
{
  "success": false,
  "error": "Пост не найден",
  "message": "Пост с ID 999 не существует"
}
```

### Внутренняя ошибка (500)
```json
{
  "success": false,
  "error": "Ошибка при создании поста",
  "message": "Не удалось создать пост"
}
```

## Установка и запуск

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python run.py
```

3. Тестирование обработки ошибок:
```bash
python test_errors.py
```

## Тестирование

Скрипт `test_errors.py` проверяет:
- Несуществующие эндпоинты
- Несуществующие ресурсы
- Невалидные данные
- Неверные HTTP методы
- Граничные случаи валидации

## Логирование

### Примеры логов:
```
2024-01-01 12:00:00,123 - __main__ - INFO - Запрос: POST /posts от 127.0.0.1
2024-01-01 12:00:00,456 - __main__ - INFO - Создан новый пост с ID 1: Мой первый пост
2024-01-01 12:00:00,789 - __main__ - INFO - Ответ: POST /posts - Успешно
```

### Ошибки:
```
2024-01-01 12:00:00,123 - __main__ - WARNING - Ошибки валидации при создании поста: ['Заголовок должен содержать минимум 3 символа']
2024-01-01 12:00:00,456 - __main__ - ERROR - Ошибка при создании поста: database connection failed
```

## Структура файлов
```
1-3/
├── app.py              # Flask приложение с обработкой ошибок
├── run.py              # Точка входа
├── test_errors.py      # Тестирование обработки ошибок
├── blog_api.log        # Файл логов (создается автоматически)
├── requirements.txt    # Зависимости Python
└── README.md          # Документация
```

## Улучшения по сравнению с предыдущими версиями

1. **Детальная валидация**: Проверка длины полей, обязательных данных
2. **Структурированные ошибки**: Единый формат ответов об ошибках
3. **Комплексное логирование**: Отслеживание всех операций
4. **Обработка исключений**: Graceful handling всех ошибок
5. **Безопасность**: Валидация и очистка входных данных

## Следующие шаги
- Реализация API эндпоинтов для комментариев (задача 2-1)
- Добавление валидации для комментариев (задача 2-2)
